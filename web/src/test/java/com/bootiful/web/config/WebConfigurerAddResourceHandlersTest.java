// ********RoostGPT********
/*
Test generated by RoostGPT for test test-5404 using AI Type Open AI and AI Model gpt-4-1106-preview
ROOST_METHOD_HASH=addResourceHandlers_9d4db5f2e2
ROOST_METHOD_SIG_HASH=addResourceHandlers_289a4a6d21
Scenario 1: Resource handler registration when no mapping for pattern exists
Details:  
  TestName: shouldRegisterResourceHandlerIfNoMappingExists
  Description: This test checks that the resource handler for the pattern "/dist/**" is registered if there is currently no mapping for that pattern.
Execution:
  Arrange: Create a mock ResourceHandlerRegistry that does not have a mapping for the pattern "/dist/**".
  Act: Invoke the addResourceHandlers method with the mock registry.
  Assert: Verify that addResourceHandler is called with the pattern "/dist/**" on the mock registry.
Validation: 
  The assertion aims to verify that the method correctly checks for the existence of a mapping and registers a new resource handler if none exists. This is significant because it ensures that static resources are served correctly from the specified location.
Scenario 2: Resource handler registration is skipped when mapping for pattern already exists
Details:  
  TestName: shouldNotRegisterResourceHandlerIfMappingExists
  Description: This test checks that the resource handler for the pattern "/dist/**" is not registered if there is already a mapping for that pattern.
Execution:
  Arrange: Create a mock ResourceHandlerRegistry that already has a mapping for the pattern "/dist/**".
  Act: Invoke the addResourceHandlers method with the mock registry.
  Assert: Verify that addResourceHandler is not called on the mock registry.
Validation: 
  The assertion aims to verify that the method does not register a duplicate resource handler if one already exists, which is important to prevent conflicts and ensure that the correct resources are served.
Scenario 3: Resource location is set correctly when registering resource handler
Details:  
  TestName: shouldSetCorrectResourceLocationWhenRegisteringHandler
  Description: This test verifies that when the resource handler for "/dist/**" is registered, it is configured with the correct resource location "classpath:/static/vendor/".
Execution:
  Arrange: Create a mock ResourceHandlerRegistry without a mapping for "/dist/**" and a mock ResourceHandlerRegistration.
  Act: Invoke the addResourceHandlers method and capture the ResourceHandlerRegistration for "/dist/**".
  Assert: Verify that addResourceLocations is called with "classpath:/static/vendor/" on the captured ResourceHandlerRegistration.
Validation: 
  The assertion confirms that the method sets the correct resource location, which is crucial for ensuring that the application serves the correct static resources.
Scenario 4: Resource handler registration behaves correctly with multiple invocations
Details:  
  TestName: shouldBehaveIdempotentlyOnMultipleInvocations
  Description: This test ensures that calling the addResourceHandlers method multiple times does not lead to multiple registrations if the mapping already exists.
Execution:
  Arrange: Create a mock ResourceHandlerRegistry with no initial mappings, then invoke the addResourceHandlers method to add the "/dist/**" pattern.
  Act: Invoke the addResourceHandlers method again with the same registry.
  Assert: Verify that addResourceHandler is not called a second time for the "/dist/**" pattern.
Validation: 
  The assertion checks that the method is idempotent with respect to resource handler registration, which is essential for avoiding duplicate handler registration during repeated configurations or refreshes of the application context.
*/
// ********RoostGPT********
package com.bootiful.web.config;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import static org.mockito.Mockito.*;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistration;
import org.junit.jupiter.api.*;

@Tag("com.bootiful.web.config")
@Tag("com.bootiful.web.config.addResourceHandlers")
class WebConfigurerAddResourceHandlersTest {
    private ResourceHandlerRegistry registry;
    private WebConfigurer webConfigurer;
    @BeforeEach
    public void setUp() {
        registry = Mockito.mock(ResourceHandlerRegistry.class);
        webConfigurer = new WebConfigurer();
    }
    @Test
    public void shouldRegisterResourceHandlerIfNoMappingExists() {
        when(registry.hasMappingForPattern("/dist/**")).thenReturn(false);
        webConfigurer.addResourceHandlers(registry);
        verify(registry, times(1)).addResourceHandler("/dist/**");
    }
    @Test
    public void shouldNotRegisterResourceHandlerIfMappingExists() {
        when(registry.hasMappingForPattern("/dist/**")).thenReturn(true);
        webConfigurer.addResourceHandlers(registry);
        verify(registry, never()).addResourceHandler("/dist/**");
    }
    @Test
    public void shouldSetCorrectResourceLocationWhenRegisteringHandler() {
        when(registry.hasMappingForPattern("/dist/**")).thenReturn(false);
        ResourceHandlerRegistration registration = Mockito.mock(ResourceHandlerRegistration.class);
        when(registry.addResourceHandler("/dist/**")).thenReturn(registration);
        webConfigurer.addResourceHandlers(registry);
        verify(registration, times(1)).addResourceLocations("classpath:/static/vendor/");
    }
    @Test
    public void shouldBehaveIdempotentlyOnMultipleInvocations() {
        when(registry.hasMappingForPattern("/dist/**")).thenReturn(false).thenReturn(true);
        webConfigurer.addResourceHandlers(registry);
        webConfigurer.addResourceHandlers(registry);
        verify(registry, times(1)).addResourceHandler("/dist/**");
    }
}