// ********RoostGPT********
/*
Test generated by RoostGPT for test test-5404 using AI Type Open AI and AI Model gpt-4-1106-preview

ROOST_METHOD_HASH=configure_eb5ea15663
ROOST_METHOD_SIG_HASH=configure_c60d0d12aa

Scenario 1: Successful AuthenticationManagerBuilder Configuration

Details:  
  TestName: configureAuthenticationManagerBuilderSuccessfully
  Description: This test ensures that the configure method sets up the AuthenticationManagerBuilder with the correct UserDetailsService and PasswordEncoder.
Execution:
  Arrange: Mock the UserDetailsService and create a PasswordEncoder instance. Instantiate the AuthenticationManagerBuilder.
  Act: Call the configure method with the mocked AuthenticationManagerBuilder.
  Assert: Verify that the UserDetailsService and PasswordEncoder are set correctly in the AuthenticationManagerBuilder.
Validation: 
  Clarify that the UserDetailsService and PasswordEncoder have been set as expected, which is crucial for the application's authentication process to work correctly.
  Elaborate on the significance of the test in ensuring that the authentication process will be able to handle user authentication requests with the appropriate services.

Scenario 2: configure Throws Exception When UserDetailsService Is Not Set

Details:  
  TestName: configureThrowsExceptionWithoutUserDetailsService
  Description: This test checks that the configure method throws an exception when the UserDetailsService is not provided or is null.
Execution:
  Arrange: Instantiate the AuthenticationManagerBuilder without setting a UserDetailsService.
  Act: Attempt to call the configure method and expect an exception.
  Assert: Assert that the expected exception is thrown.
Validation: 
  Clarify that an exception should be thrown when a required component, such as the UserDetailsService, is missing, which is necessary to prevent misconfiguration of the authentication mechanism.
  Elaborate on the significance of the test in ensuring that the system fails fast and alerts the developer or operator to configuration issues.

Scenario 3: configure Uses Custom PasswordEncoder Bean

Details:  
  TestName: configureUsesCustomPasswordEncoderBean
  Description: This test ensures that the configure method uses the custom PasswordEncoder bean defined in the same configuration class.
Execution:
  Arrange: Mock the UserDetailsService and define a custom PasswordEncoder bean.
  Act: Call the configure method with the mocked AuthenticationManagerBuilder.
  Assert: Verify that the custom PasswordEncoder bean is used in the AuthenticationManagerBuilder.
Validation: 
  Clarify that the PasswordEncoder bean being used is the same as the one defined in the configuration class, which is essential for maintaining consistency in password encoding across the application.
  Elaborate on the significance of the test in ensuring that the custom PasswordEncoder is properly integrated into the authentication configuration.
*/

// ********RoostGPT********
package com.bootiful.web.config.security;

import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.junit.jupiter.api.Assertions.assertThrows;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;

public class SecurityConfigurerConfigure792Test {
    @Mock
    private UserDetailsService userDetailsService;
    @Mock
    private PasswordEncoder passwordEncoder;
    @InjectMocks
    private WebSecurityConfigurerAdapter configurer = new WebSecurityConfigurerAdapter() {
        @Override
        protected void configure(AuthenticationManagerBuilder auth) throws Exception {
            auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
        }
        @Bean
        public PasswordEncoder passwordEncoder() {
            return new BCryptPasswordEncoder();
        }
    };
    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }
    @Test
    public void configureAuthenticationManagerBuilderSuccessfully() throws Exception {
        AuthenticationManagerBuilder auth = new AuthenticationManagerBuilder(null);
        configurer.configure(auth);
        verify(auth).userDetailsService(userDetailsService);
        verify(auth).passwordEncoder(passwordEncoder);
    }
    @Test
    public void configureThrowsExceptionWithoutUserDetailsService() {
        AuthenticationManagerBuilder auth = new AuthenticationManagerBuilder(null);
        Exception exception = assertThrows(UsernameNotFoundException.class, () -> {
            WebSecurityConfigurerAdapter faultyConfigurer = new WebSecurityConfigurerAdapter() {
                @Override
                protected void configure(AuthenticationManagerBuilder auth) throws Exception {
                    auth.userDetailsService(null).passwordEncoder(passwordEncoder());
                }
            };
            faultyConfigurer.configure(auth);
        });
        // No need to re-throw the exception, as assertThrows already verifies it
    }
    @Test
    public void configureUsesCustomPasswordEncoderBean() throws Exception {
        AuthenticationManagerBuilder auth = new AuthenticationManagerBuilder(null);
        PasswordEncoder customPasswordEncoder = mock(PasswordEncoder.class);
        when(configurer.passwordEncoder()).thenReturn(customPasswordEncoder);
        configurer.configure(auth);
        verify(auth).passwordEncoder(customPasswordEncoder);
    }
}
