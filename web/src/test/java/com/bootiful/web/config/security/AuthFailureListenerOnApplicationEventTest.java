// ********RoostGPT********
/*
Test generated by RoostGPT for test test-5404 using AI Type Open AI and AI Model gpt-4-1106-preview

ROOST_METHOD_HASH=onApplicationEvent_186450f687
ROOST_METHOD_SIG_HASH=onApplicationEvent_1a864f94fa

``` 
Scenario 1: User authentication failure with a valid username and increment of login failures count

Details:  
  TestName: incrementLoginFailuresOnBadCredentials
  Description: This test verifies that the login failures count is incremented by one when a user with a valid username fails to authenticate.
Execution:
  Arrange: Mock the userRepository to return a User object with a specific loginFailuresCount when findByUsername is called. Create an AuthenticationFailureBadCredentialsEvent with a mocked Authentication object containing the username.
  Act: Call onApplicationEvent with the created event.
  Assert: Verify that the User object's loginFailuresCount is incremented by one and userRepository.save is called with the updated User object.
Validation: 
  The assertion confirms that the method correctly updates the failure count, which is crucial for tracking failed login attempts and potentially locking out the user after a threshold is reached.

Scenario 2: User disabled after reaching maximum login failures

Details:  
  TestName: disableUserOnMaxLoginFailures
  Description: This test checks whether the user account is disabled after reaching the maximum number of allowed login failures.
Execution:
  Arrange: Mock the userRepository to return a User object that has 4 failed login attempts already. Create an AuthenticationFailureBadCredentialsEvent with a mocked Authentication object containing the username.
  Act: Call onApplicationEvent with the created event.
  Assert: Verify that the User object's isEnabled method returns false and userRepository.save is called with the updated User object.
Validation: 
  The assertion ensures that the business logic of disabling a user account after 5 failed login attempts is implemented correctly.

Scenario 3: User record not found for given username

Details:  
  TestName: noActionOnUserNotFound
  Description: This test ensures that no action is taken if the userRepository cannot find a user for the given username.
Execution:
  Arrange: Mock the userRepository to return null when findByUsername is called with a non-existent username. Create an AuthenticationFailureBadCredentialsEvent with a mocked Authentication object containing the non-existent username.
  Act: Call onApplicationEvent with the created event.
  Assert: Verify that userRepository.save is never called.
Validation: 
  The assertion verifies that the method does not attempt to update or save a non-existent user, which is important to prevent null pointer exceptions and ensure system stability.

Scenario 4: Login details and time are updated on authentication failure

Details:  
  TestName: updateLoginDetailsAndTimeOnFailure
  Description: This test ensures that the user's last login details and time are updated upon a failed authentication attempt.
Execution:
  Arrange: Mock the userRepository to return a User object. Create an AuthenticationFailureBadCredentialsEvent with a mocked Authentication object containing the username and WebAuthenticationDetails.
  Act: Call onApplicationEvent with the created event.
  Assert: Verify that the User object's lastLoginDetails and lastLoginTime are updated and userRepository.save is called with the updated User object.
Validation: 
  The assertion checks that the method correctly records the time and details of the failed login attempt, which is vital for auditing and troubleshooting purposes.

Scenario 5: Login details are set to null if authentication details are not available

Details:  
  TestName: setLoginDetailsToNullIfNotAvailable
  Description: This test verifies that the user's last login details are set to null if the authentication event does not contain any details.
Execution:
  Arrange: Mock the userRepository to return a User object. Create an AuthenticationFailureBadCredentialsevent with a mocked Authentication object that has null details.
  Act: Call onApplicationEvent with the created event.
  Assert: Verify that the User object's lastLoginDetails is set to null and userRepository.save is called with the updated User object.
Validation: 
  The assertion ensures that the method handles cases where login details are not present by setting the lastLoginDetails to null, which prevents storing incorrect or incomplete information.
```
*/

// ********RoostGPT********
package com.bootiful.web.config.security;

import com.bootiful.framework.domain.User;
import com.bootiful.framework.repository.UserRepository;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.ApplicationListener;
import org.springframework.security.authentication.event.AuthenticationFailureBadCredentialsEvent;
import org.springframework.security.core.Authentication;
import org.springframework.security.web.authentication.WebAuthenticationDetails;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import java.util.Date;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
class AuthFailureListenerOnApplicationEventTest {
    @Mock
    private UserRepository userRepository;
    
    @InjectMocks
    private AuthFailureListener authFailureListener;
    
    @Test
    public void incrementLoginFailuresOnBadCredentials() {
        // Arrange
        String username = "valid_username";
        User mockUser = mock(User.class);
        when(mockUser.getLoginFailuresCount()).thenReturn(2);
        when(userRepository.findByUsername(username)).thenReturn(mockUser);
        Authentication authentication = mock(Authentication.class);
        when(authentication.getPrincipal()).thenReturn(username);
        AuthenticationFailureBadCredentialsEvent event = new AuthenticationFailureBadCredentialsEvent(authentication, new Exception());
        
        // Act
        authFailureListener.onApplicationEvent(event);
        
        // Assert
        verify(mockUser).setLoginFailuresCount(3);
        verify(userRepository).save(mockUser);
    }
    
    @Test
    public void disableUserOnMaxLoginFailures() {
        // Arrange
        String username = "user_reaching_limit";
        User mockUser = mock(User.class);
        when(mockUser.getLoginFailuresCount()).thenReturn(4);
        when(userRepository.findByUsername(username)).thenReturn(mockUser);
        Authentication authentication = mock(Authentication.class);
        when(authentication.getPrincipal()).thenReturn(username);
        AuthenticationFailureBadCredentialsEvent event = new AuthenticationFailureBadCredentialsEvent(authentication, new Exception());
        
        // Act
        authFailureListener.onApplicationEvent(event);
        
        // Assert
        verify(mockUser).setEnabled(false);
        verify(userRepository).save(mockUser);
    }
    
    @Test
    public void noActionOnUserNotFound() {
        // Arrange
        String username = "nonexistent_username";
        when(userRepository.findByUsername(username)).thenReturn(null);
        Authentication authentication = mock(Authentication.class);
        when(authentication.getPrincipal()).thenReturn(username);
        AuthenticationFailureBadCredentialsEvent event = new AuthenticationFailureBadCredentialsEvent(authentication, new Exception());
        
        // Act
        authFailureListener.onApplicationEvent(event);
        
        // Assert
        verify(userRepository, never()).save(any(User.class));
    }
    
    @Test
    public void updateLoginDetailsAndTimeOnFailure() {
        // Arrange
        String username = "username_with_details";
        User mockUser = mock(User.class);
        when(userRepository.findByUsername(username)).thenReturn(mockUser);
        Authentication authentication = mock(Authentication.class);
        WebAuthenticationDetails details = mock(WebAuthenticationDetails.class);
        when(details.getRemoteAddress()).thenReturn("127.0.0.1");
        when(details.getSessionId()).thenReturn("session_id");
        when(authentication.getPrincipal()).thenReturn(username);
        when(authentication.getDetails()).thenReturn(details);
        AuthenticationFailureBadCredentialsEvent event = new AuthenticationFailureBadCredentialsEvent(authentication, new Exception());
        
        // Act
        authFailureListener.onApplicationEvent(event);
        
        // Assert
        verify(mockUser).setLastLoginDetails(anyString());
        verify(mockUser).setLastLoginTime(any(Date.class));
        verify(userRepository).save(mockUser);
    }
    
    @Test
    public void setLoginDetailsToNullIfNotAvailable() {
        // Arrange
        String username = "username_without_details";
        User mockUser = mock(User.class);
        when(userRepository.findByUsername(username)).thenReturn(mockUser);
        Authentication authentication = mock(Authentication.class);
        when(authentication.getPrincipal()).thenReturn(username);
        when(authentication.getDetails()).thenReturn(null);
        AuthenticationFailureBadCredentialsEvent event = new AuthenticationFailureBadCredentialsEvent(authentication, new Exception());
        
        // Act
        authFailureListener.onApplicationEvent(event);
        
        // Assert
        verify(mockUser).setLastLoginDetails(null);
        verify(userRepository).save(mockUser);
    }
    
    // Inner class to simulate the actual listener
    @Component
    public static class AuthFailureListener implements ApplicationListener<AuthenticationFailureBadCredentialsEvent> {
        
        @Autowired
        private UserRepository userRepository;
        
        @Override
        @Transactional
        public void onApplicationEvent(AuthenticationFailureBadCredentialsEvent event) {
            String username = (String) event.getAuthentication().getPrincipal();
            User user = userRepository.findByUsername(username);
            if (user != null) {
                int loginFailures = user.getLoginFailuresCount() + 1;
                if (loginFailures >= 5) {
                    user.setEnabled(false);
                }
                String strDetail = null;
                Object details = event.getAuthentication().getDetails();
                if (details instanceof WebAuthenticationDetails) {
                    strDetail = "IP: " + ((WebAuthenticationDetails) details).getRemoteAddress() + " SessionID: " + ((WebAuthenticationDetails) details).getSessionId();
                }
                user.setLastLoginDetails(strDetail);
                user.setLastLoginTime(new Date());
                user.setLoginFailuresCount(loginFailures);
                userRepository.save(user);
            }
        }
    }
}
